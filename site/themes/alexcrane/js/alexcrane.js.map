{"version":3,"names":[],"mappings":"","sources":["alexcrane.js"],"sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nVue.directive('scroll', {\n    inserted: function inserted(el, binding) {\n        var f = function f(evt) {\n            if (binding.value(evt, el)) {\n                window.removeEventListener('scroll', f);\n            }\n        };\n        window.addEventListener('scroll', f);\n    }\n});\n\nvar app = new Vue({\n    delimiters: ['${', '}'],\n    el: '#app',\n    data: {\n        scrolledPast100: false,\n        mobileNavOpen: false,\n        subNavOpen: false,\n        footerVisible: false,\n        lastScrollTop: 0,\n        scrollTop: 0,\n        scrollingDown: false,\n        hideHeadNav: false,\n        hideSubNav: false,\n        headerBG: false,\n        folioHover: false,\n        homeAudioVisible: false,\n        vid: '',\n        logoHovering: false\n    },\n    methods: {\n        appScroll: function appScroll(evt, el) {\n            this.folioHover = false;\n            this.subNavOpen = false;\n            this.scrolledPast100 = window.scrollY > 100;\n\n            this.scrollTop = window.pageYOffset;\n\n            if (this.scrollTop > this.lastScrollTop) {\n                this.scrollingDown = true;\n            } else {\n                this.scrollingDown = false;\n            };\n\n            if (this.scrollingDown) {\n                this.hideHeadNav = true;\n                this.hideSubNav = true;\n            } else {\n                if (this.lastScrollTop - 20 > this.scrollTop) {\n                    this.hideHeadNav = false;\n                    this.hideSubNav = false;\n                };\n            };\n\n            if (!this.scrolledPast100) {\n                this.hideHeadNav = false;\n                this.hideSubNav = false;\n            };\n\n            if (this.scrolledPast100) {\n                if (!this.scrollingDown) {\n                    this.headerBG = true;\n                };\n                if (this.footerVisible) {\n                    this.headerBG = true;\n                };\n            } else {\n                this.headerBG = false;\n            };\n\n            this.lastScrollTop = this.scrollTop;\n        },\n        headNavHover: function headNavHover() {\n            this.hideHeadNav = false;\n        },\n        subNavHover: function subNavHover() {\n            this.hideSubNav = false;\n        },\n        toggleMobileNav: function toggleMobileNav() {\n            this.mobileNavOpen = !this.mobileNavOpen;\n        },\n        toggleSubNav: function toggleSubNav() {\n            this.subNavOpen = !this.subNavOpen;\n        },\n        footerVisibility: function footerVisibility(footerVisible) {\n            this.footerVisible = footerVisible;\n            this.hideHeadNav = false;\n            this.hideSubNav = false;\n        },\n        homeAudioPlayer: function homeAudioPlayer(homeAudioVisible) {\n            this.homeAudioVisible = homeAudioVisible;\n            this.vid = document.getElementById(\"homeAudioPlayer\");\n\n            if (this.homeAudioVisible) {\n                this.vid.play();\n            } else {\n                this.vid.pause();\n            };\n        },\n        folioLinkHover: function folioLinkHover() {\n            this.folioHover = !this.folioHover;\n        },\n        logoHover: function logoHover() {\n            console.log('logoHovering');\n            this.logoHovering = !this.logoHovering;\n        }\n    }\n});\n\n},{}],2:[function(require,module,exports){\n\"use strict\";\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*!\nWaypoints - 4.0.1\nCopyright Â© 2011-2016 Caleb Troughton\nLicensed under the MIT license.\nhttps://github.com/imakewebthings/waypoints/blob/master/licenses.txt\n*/\n!function () {\n  \"use strict\";\n  function t(n) {\n    if (!n) throw new Error(\"No options passed to Waypoint constructor\");if (!n.element) throw new Error(\"No element option passed to Waypoint constructor\");if (!n.handler) throw new Error(\"No handler option passed to Waypoint constructor\");this.key = \"waypoint-\" + e, this.options = t.Adapter.extend({}, t.defaults, n), this.element = this.options.element, this.adapter = new t.Adapter(this.element), this.callback = n.handler, this.axis = this.options.horizontal ? \"horizontal\" : \"vertical\", this.enabled = this.options.enabled, this.triggerPoint = null, this.group = t.Group.findOrCreate({ name: this.options.group, axis: this.axis }), this.context = t.Context.findOrCreateByElement(this.options.context), t.offsetAliases[this.options.offset] && (this.options.offset = t.offsetAliases[this.options.offset]), this.group.add(this), this.context.add(this), i[this.key] = this, e += 1;\n  }var e = 0,\n      i = {};t.prototype.queueTrigger = function (t) {\n    this.group.queueTrigger(this, t);\n  }, t.prototype.trigger = function (t) {\n    this.enabled && this.callback && this.callback.apply(this, t);\n  }, t.prototype.destroy = function () {\n    this.context.remove(this), this.group.remove(this), delete i[this.key];\n  }, t.prototype.disable = function () {\n    return this.enabled = !1, this;\n  }, t.prototype.enable = function () {\n    return this.context.refresh(), this.enabled = !0, this;\n  }, t.prototype.next = function () {\n    return this.group.next(this);\n  }, t.prototype.previous = function () {\n    return this.group.previous(this);\n  }, t.invokeAll = function (t) {\n    var e = [];for (var n in i) {\n      e.push(i[n]);\n    }for (var o = 0, r = e.length; r > o; o++) {\n      e[o][t]();\n    }\n  }, t.destroyAll = function () {\n    t.invokeAll(\"destroy\");\n  }, t.disableAll = function () {\n    t.invokeAll(\"disable\");\n  }, t.enableAll = function () {\n    t.Context.refreshAll();for (var e in i) {\n      i[e].enabled = !0;\n    }return this;\n  }, t.refreshAll = function () {\n    t.Context.refreshAll();\n  }, t.viewportHeight = function () {\n    return window.innerHeight || document.documentElement.clientHeight;\n  }, t.viewportWidth = function () {\n    return document.documentElement.clientWidth;\n  }, t.adapters = [], t.defaults = { context: window, continuous: !0, enabled: !0, group: \"default\", horizontal: !1, offset: 0 }, t.offsetAliases = { \"bottom-in-view\": function bottomInView() {\n      return this.context.innerHeight() - this.adapter.outerHeight();\n    }, \"right-in-view\": function rightInView() {\n      return this.context.innerWidth() - this.adapter.outerWidth();\n    } }, window.Waypoint = t;\n}(), function () {\n  \"use strict\";\n  function t(t) {\n    window.setTimeout(t, 1e3 / 60);\n  }function e(t) {\n    this.element = t, this.Adapter = o.Adapter, this.adapter = new this.Adapter(t), this.key = \"waypoint-context-\" + i, this.didScroll = !1, this.didResize = !1, this.oldScroll = { x: this.adapter.scrollLeft(), y: this.adapter.scrollTop() }, this.waypoints = { vertical: {}, horizontal: {} }, t.waypointContextKey = this.key, n[t.waypointContextKey] = this, i += 1, o.windowContext || (o.windowContext = !0, o.windowContext = new e(window)), this.createThrottledScrollHandler(), this.createThrottledResizeHandler();\n  }var i = 0,\n      n = {},\n      o = window.Waypoint,\n      r = window.onload;e.prototype.add = function (t) {\n    var e = t.options.horizontal ? \"horizontal\" : \"vertical\";this.waypoints[e][t.key] = t, this.refresh();\n  }, e.prototype.checkEmpty = function () {\n    var t = this.Adapter.isEmptyObject(this.waypoints.horizontal),\n        e = this.Adapter.isEmptyObject(this.waypoints.vertical),\n        i = this.element == this.element.window;t && e && !i && (this.adapter.off(\".waypoints\"), delete n[this.key]);\n  }, e.prototype.createThrottledResizeHandler = function () {\n    function t() {\n      e.handleResize(), e.didResize = !1;\n    }var e = this;this.adapter.on(\"resize.waypoints\", function () {\n      e.didResize || (e.didResize = !0, o.requestAnimationFrame(t));\n    });\n  }, e.prototype.createThrottledScrollHandler = function () {\n    function t() {\n      e.handleScroll(), e.didScroll = !1;\n    }var e = this;this.adapter.on(\"scroll.waypoints\", function () {\n      (!e.didScroll || o.isTouch) && (e.didScroll = !0, o.requestAnimationFrame(t));\n    });\n  }, e.prototype.handleResize = function () {\n    o.Context.refreshAll();\n  }, e.prototype.handleScroll = function () {\n    var t = {},\n        e = { horizontal: { newScroll: this.adapter.scrollLeft(), oldScroll: this.oldScroll.x, forward: \"right\", backward: \"left\" }, vertical: { newScroll: this.adapter.scrollTop(), oldScroll: this.oldScroll.y, forward: \"down\", backward: \"up\" } };for (var i in e) {\n      var n = e[i],\n          o = n.newScroll > n.oldScroll,\n          r = o ? n.forward : n.backward;for (var s in this.waypoints[i]) {\n        var l = this.waypoints[i][s];if (null !== l.triggerPoint) {\n          var a = n.oldScroll < l.triggerPoint,\n              h = n.newScroll >= l.triggerPoint,\n              p = a && h,\n              u = !a && !h;(p || u) && (l.queueTrigger(r), t[l.group.id] = l.group);\n        }\n      }\n    }for (var d in t) {\n      t[d].flushTriggers();\n    }this.oldScroll = { x: e.horizontal.newScroll, y: e.vertical.newScroll };\n  }, e.prototype.innerHeight = function () {\n    return this.element == this.element.window ? o.viewportHeight() : this.adapter.innerHeight();\n  }, e.prototype.remove = function (t) {\n    delete this.waypoints[t.axis][t.key], this.checkEmpty();\n  }, e.prototype.innerWidth = function () {\n    return this.element == this.element.window ? o.viewportWidth() : this.adapter.innerWidth();\n  }, e.prototype.destroy = function () {\n    var t = [];for (var e in this.waypoints) {\n      for (var i in this.waypoints[e]) {\n        t.push(this.waypoints[e][i]);\n      }\n    }for (var n = 0, o = t.length; o > n; n++) {\n      t[n].destroy();\n    }\n  }, e.prototype.refresh = function () {\n    var t,\n        e = this.element == this.element.window,\n        i = e ? void 0 : this.adapter.offset(),\n        n = {};this.handleScroll(), t = { horizontal: { contextOffset: e ? 0 : i.left, contextScroll: e ? 0 : this.oldScroll.x, contextDimension: this.innerWidth(), oldScroll: this.oldScroll.x, forward: \"right\", backward: \"left\", offsetProp: \"left\" }, vertical: { contextOffset: e ? 0 : i.top, contextScroll: e ? 0 : this.oldScroll.y, contextDimension: this.innerHeight(), oldScroll: this.oldScroll.y, forward: \"down\", backward: \"up\", offsetProp: \"top\" } };for (var r in t) {\n      var s = t[r];for (var l in this.waypoints[r]) {\n        var a,\n            h,\n            p,\n            u,\n            d,\n            f = this.waypoints[r][l],\n            c = f.options.offset,\n            w = f.triggerPoint,\n            y = 0,\n            g = null == w;f.element !== f.element.window && (y = f.adapter.offset()[s.offsetProp]), \"function\" == typeof c ? c = c.apply(f) : \"string\" == typeof c && (c = parseFloat(c), f.options.offset.indexOf(\"%\") > -1 && (c = Math.ceil(s.contextDimension * c / 100))), a = s.contextScroll - s.contextOffset, f.triggerPoint = Math.floor(y + a - c), h = w < s.oldScroll, p = f.triggerPoint >= s.oldScroll, u = h && p, d = !h && !p, !g && u ? (f.queueTrigger(s.backward), n[f.group.id] = f.group) : !g && d ? (f.queueTrigger(s.forward), n[f.group.id] = f.group) : g && s.oldScroll >= f.triggerPoint && (f.queueTrigger(s.forward), n[f.group.id] = f.group);\n      }\n    }return o.requestAnimationFrame(function () {\n      for (var t in n) {\n        n[t].flushTriggers();\n      }\n    }), this;\n  }, e.findOrCreateByElement = function (t) {\n    return e.findByElement(t) || new e(t);\n  }, e.refreshAll = function () {\n    for (var t in n) {\n      n[t].refresh();\n    }\n  }, e.findByElement = function (t) {\n    return n[t.waypointContextKey];\n  }, window.onload = function () {\n    r && r(), e.refreshAll();\n  }, o.requestAnimationFrame = function (e) {\n    var i = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || t;i.call(window, e);\n  }, o.Context = e;\n}(), function () {\n  \"use strict\";\n  function t(t, e) {\n    return t.triggerPoint - e.triggerPoint;\n  }function e(t, e) {\n    return e.triggerPoint - t.triggerPoint;\n  }function i(t) {\n    this.name = t.name, this.axis = t.axis, this.id = this.name + \"-\" + this.axis, this.waypoints = [], this.clearTriggerQueues(), n[this.axis][this.name] = this;\n  }var n = { vertical: {}, horizontal: {} },\n      o = window.Waypoint;i.prototype.add = function (t) {\n    this.waypoints.push(t);\n  }, i.prototype.clearTriggerQueues = function () {\n    this.triggerQueues = { up: [], down: [], left: [], right: [] };\n  }, i.prototype.flushTriggers = function () {\n    for (var i in this.triggerQueues) {\n      var n = this.triggerQueues[i],\n          o = \"up\" === i || \"left\" === i;n.sort(o ? e : t);for (var r = 0, s = n.length; s > r; r += 1) {\n        var l = n[r];(l.options.continuous || r === n.length - 1) && l.trigger([i]);\n      }\n    }this.clearTriggerQueues();\n  }, i.prototype.next = function (e) {\n    this.waypoints.sort(t);var i = o.Adapter.inArray(e, this.waypoints),\n        n = i === this.waypoints.length - 1;return n ? null : this.waypoints[i + 1];\n  }, i.prototype.previous = function (e) {\n    this.waypoints.sort(t);var i = o.Adapter.inArray(e, this.waypoints);return i ? this.waypoints[i - 1] : null;\n  }, i.prototype.queueTrigger = function (t, e) {\n    this.triggerQueues[e].push(t);\n  }, i.prototype.remove = function (t) {\n    var e = o.Adapter.inArray(t, this.waypoints);e > -1 && this.waypoints.splice(e, 1);\n  }, i.prototype.first = function () {\n    return this.waypoints[0];\n  }, i.prototype.last = function () {\n    return this.waypoints[this.waypoints.length - 1];\n  }, i.findOrCreate = function (t) {\n    return n[t.axis][t.name] || new i(t);\n  }, o.Group = i;\n}(), function () {\n  \"use strict\";\n  function t(t) {\n    return t === t.window;\n  }function e(e) {\n    return t(e) ? e : e.defaultView;\n  }function i(t) {\n    this.element = t, this.handlers = {};\n  }var n = window.Waypoint;i.prototype.innerHeight = function () {\n    var e = t(this.element);return e ? this.element.innerHeight : this.element.clientHeight;\n  }, i.prototype.innerWidth = function () {\n    var e = t(this.element);return e ? this.element.innerWidth : this.element.clientWidth;\n  }, i.prototype.off = function (t, e) {\n    function i(t, e, i) {\n      for (var n = 0, o = e.length - 1; o > n; n++) {\n        var r = e[n];i && i !== r || t.removeEventListener(r);\n      }\n    }var n = t.split(\".\"),\n        o = n[0],\n        r = n[1],\n        s = this.element;if (r && this.handlers[r] && o) i(s, this.handlers[r][o], e), this.handlers[r][o] = [];else if (o) for (var l in this.handlers) {\n      i(s, this.handlers[l][o] || [], e), this.handlers[l][o] = [];\n    } else if (r && this.handlers[r]) {\n      for (var a in this.handlers[r]) {\n        i(s, this.handlers[r][a], e);\n      }this.handlers[r] = {};\n    }\n  }, i.prototype.offset = function () {\n    if (!this.element.ownerDocument) return null;var t = this.element.ownerDocument.documentElement,\n        i = e(this.element.ownerDocument),\n        n = { top: 0, left: 0 };return this.element.getBoundingClientRect && (n = this.element.getBoundingClientRect()), { top: n.top + i.pageYOffset - t.clientTop, left: n.left + i.pageXOffset - t.clientLeft };\n  }, i.prototype.on = function (t, e) {\n    var i = t.split(\".\"),\n        n = i[0],\n        o = i[1] || \"__default\",\n        r = this.handlers[o] = this.handlers[o] || {},\n        s = r[n] = r[n] || [];s.push(e), this.element.addEventListener(n, e);\n  }, i.prototype.outerHeight = function (e) {\n    var i,\n        n = this.innerHeight();return e && !t(this.element) && (i = window.getComputedStyle(this.element), n += parseInt(i.marginTop, 10), n += parseInt(i.marginBottom, 10)), n;\n  }, i.prototype.outerWidth = function (e) {\n    var i,\n        n = this.innerWidth();return e && !t(this.element) && (i = window.getComputedStyle(this.element), n += parseInt(i.marginLeft, 10), n += parseInt(i.marginRight, 10)), n;\n  }, i.prototype.scrollLeft = function () {\n    var t = e(this.element);return t ? t.pageXOffset : this.element.scrollLeft;\n  }, i.prototype.scrollTop = function () {\n    var t = e(this.element);return t ? t.pageYOffset : this.element.scrollTop;\n  }, i.extend = function () {\n    function t(t, e) {\n      if (\"object\" == (typeof t === \"undefined\" ? \"undefined\" : _typeof(t)) && \"object\" == (typeof e === \"undefined\" ? \"undefined\" : _typeof(e))) for (var i in e) {\n        e.hasOwnProperty(i) && (t[i] = e[i]);\n      }return t;\n    }for (var e = Array.prototype.slice.call(arguments), i = 1, n = e.length; n > i; i++) {\n      t(e[0], e[i]);\n    }return e[0];\n  }, i.inArray = function (t, e, i) {\n    return null == e ? -1 : e.indexOf(t, i);\n  }, i.isEmptyObject = function (t) {\n    for (var e in t) {\n      return !1;\n    }return !0;\n  }, n.adapters.push({ name: \"noframework\", Adapter: i }), n.Adapter = i;\n}();\n\n},{}]},{},[2,1]);\n"],"file":"alexcrane.js"}